"""
FILE: canonical_consumer.py

STAGE:
    Stage-2 Canonicalization

PURPOSE:
    Stateless consumption of canonical security events from Kafka.
    This module provides the consumer interface for reading canonical events
    from the canonical-metadata topic for downstream cognitive processing.

INPUTS:
    Kafka topic: canonical-metadata
    Canonical security events from canonicalization stage.

OUTPUTS:
    Canonical events to cognitive intent engine.
    Streamed events for stateful intent analysis.

IMPORTANT:
    This file must not implement logic from other stages.
    Event consumption and basic validation only.
"""

import time
import threading
import queue
from typing import Dict, Any, Optional, Callable, List
from dataclasses import dataclass

# Note: Imports from other stages should be updated when integration is needed
# from .cognitive_state import CognitiveState
# from .config import IntentEngineConfig
# from .state_store import StateStore
# from .behavioral_adapter import BehavioralAdapter, BehavioralSignals
# from .intent_update import IntentUpdater, CanonicalEvent


@dataclass
class Alert:
    """Security alert generated by intent engine."""
    timestamp: float
    user_id: str
    alert_type: str
    intent_score: float
    goal_proximity: float
    capability: float
    risk_score: float
    pattern: str
    description: str
    event_count: int
    
    def __post_init__(self):
        if self.timestamp == 0.0:
            self.timestamp = time.time()


class CanonicalConsumer:
    """
    Consumes canonical events and updates cognitive states.
    
    Processes events in real-time, generates alerts when intent
    thresholds are exceeded, and provides callback mechanisms
    for integration with external systems.
    """
    
    def __init__(self, config: IntentEngineConfig, state_store: StateStore,
                 behavioral_adapter: BehavioralAdapter, intent_updater: IntentUpdater):
        self.config = config
        self.state_store = state_store
        self.behavioral_adapter = behavioral_adapter
        self.intent_updater = intent_updater
        
        # Event processing queue for async processing
        self._event_queue = queue.Queue(maxsize=10000)
        self._processing_thread = None
        self._stop_processing = False
        
        # Alert callbacks
        self._alert_callbacks: List[Callable[[Alert], None]] = []
        
        # Statistics
        self._stats = {
            'events_processed': 0,
            'alerts_generated': 0,
            'processing_errors': 0,
            'start_time': time.time()
        }
        
        # Start processing thread
        self._start_processing()
    
    def process_event(self, event_data: Dict[str, Any]) -> Optional[Alert]:
        """
        Process a single canonical event.
        
        Args:
            event_data: Dictionary containing canonical event fields
            
        Returns:
            Alert if thresholds exceeded, None otherwise
        """
        try:
            # Parse canonical event
            canonical_event = self._parse_event(event_data)
            
            # Get or create user state
            state = self.state_store.get_state(canonical_event.user_id)
            
            # Get behavioral priors (mock if no behavioral model)
            behavioral_priors = self._get_behavioral_priors(canonical_event.user_id)
            
            # Update cognitive state
            updated_state = self.intent_updater.update_state(state, canonical_event, behavioral_priors)
            
            # Store updated state
            self.state_store.update_state(updated_state)
            
            # Check for alert conditions
            alert = self._check_alert_conditions(updated_state, canonical_event)
            
            # Update statistics
            self._stats['events_processed'] += 1
            
            if alert:
                self._stats['alerts_generated'] += 1
                self._trigger_alert_callbacks(alert)
            
            return alert
            
        except Exception as e:
            self._stats['processing_errors'] += 1
            print(f"Error processing event: {e}")
            return None
    
    def process_event_async(self, event_data: Dict[str, Any]):
        """
        Process event asynchronously (non-blocking).
        
        Args:
            event_data: Dictionary containing canonical event fields
        """
        try:
            self._event_queue.put(event_data, block=False)
        except queue.Full:
            print("Warning: Event queue is full, dropping event")
    
    def add_alert_callback(self, callback: Callable[[Alert], None]):
        """
        Add callback for alert notifications.
        
        Args:
            callback: Function to call when alert is generated
        """
        self._alert_callbacks.append(callback)
    
    def remove_alert_callback(self, callback: Callable[[Alert], None]):
        """
        Remove alert callback.
        
        """
        if callback in self._alert_callbacks:
            self._alert_callbacks.remove(callback)
    
    def get_statistics(self) -> Dict[str, Any]:
        """
        Get processing statistics.
        
        Returns:
            Dictionary with processing statistics
        """
        stats = self._stats.copy()
        stats['uptime_seconds'] = time.time() - stats['start_time']
        stats['queue_size'] = self._event_queue.qsize()
        stats['events_per_second'] = stats['events_processed'] / max(1, stats['uptime_seconds'])
        
        return stats
    
    def shutdown(self):
        """Shutdown the consumer gracefully."""
        self._stop_processing = True
        
        if self._processing_thread and self._processing_thread.is_alive():
            self._processing_thread.join(timeout=5.0)
        
        # Process remaining events in queue
        while not self._event_queue.empty():
            try:
                event_data = self._event_queue.get_nowait()
                self.process_event(event_data)
            except queue.Empty:
                break
    
    def _parse_event(self, event_data: Dict[str, Any]) -> CanonicalEvent:
        """Parse event data into CanonicalEvent."""
        required_fields = ['timestamp', 'user_id', 'action', 'object_type', 'domain',
                          'success', 'sensitivity', 'novelty', 'risk_cost', 'effort_cost', 'source']
        
        # Validate required fields
        for field in required_fields:
            if field not in event_data:
                raise ValueError(f"Missing required field: {field}")
        
        return CanonicalEvent(
            timestamp=float(event_data['timestamp']),
            user_id=str(event_data['user_id']),
            action=str(event_data['action']),
            object_type=str(event_data['object_type']),
            domain=str(event_data['domain']),
            success=bool(event_data['success']),
            sensitivity=float(event_data['sensitivity']),
            novelty=float(event_data['novelty']),
            risk_cost=float(event_data['risk_cost']),
            effort_cost=float(event_data['effort_cost']),
            source=str(event_data['source'])
        )
    
    def _get_behavioral_priors(self, user_id: str) -> Dict[str, float]:
        """
        Get behavioral priors for a user.
        
        In a real implementation, this would query an external behavioral model.
        For now, we generate mock behavioral signals.
        """
        # Mock behavioral signals (in practice, these would come from external model)
        mock_signals = BehavioralSignals(
            deviation_score=0.0,  # Normal behavior
            peer_deviation=0.0,
            time_anomaly=0.0,
            access_frequency_zscore=0.0
        )
        
        # Add some variation based on user activity
        state = self.state_store.get_state(user_id)
        if state.event_count > 50:  # Active user
            mock_signals.deviation_score = 0.5
            mock_signals.access_frequency_zscore = 0.3
        
        if state.event_count > 200:  # Very active user
            mock_signals.deviation_score = 1.0
            mock_signals.peer_deviation = 0.8
            mock_signals.time_anomaly = 0.5
        
        return self.behavioral_adapter.process_signals(user_id, mock_signals)
    
    def _check_alert_conditions(self, state: CognitiveState, event: CanonicalEvent) -> Optional[Alert]:
        """
        Check if alert conditions are met.
        
        Alert triggers when: I(t) × G(t) × C(t) > threshold
        """
        # Calculate combined risk score
        risk_score = state.intent * state.goal_proximity * state.capability
        
        # Check against threshold
        if risk_score > self.config.alert_combined_threshold:
            # Get pattern information
            pattern_info = state.get_trajectory_pattern()
            pattern = pattern_info.get('pattern', 'unknown')
            
            # Create alert
            alert = Alert(
                timestamp=event.timestamp,
                user_id=state.user_id,
                alert_type=self._determine_alert_type(state, pattern),
                intent_score=state.intent,
                goal_proximity=state.goal_proximity,
                capability=state.capability,
                risk_score=risk_score,
                pattern=pattern,
                description=self._generate_alert_description(state, pattern),
                event_count=state.event_count
            )
            
            return alert
        
        return None
    
    def _determine_alert_type(self, state: CognitiveState, pattern: str) -> str:
        """Determine alert type based on state and pattern."""
        if state.intent > 0.8 and state.goal_proximity > 0.7:
            return 'CRITICAL'
        elif state.intent > 0.6 and state.goal_proximity > 0.5:
            return 'HIGH'
        elif pattern in ['learning_planning', 'persistence_after_failure', 'malicious_confidence']:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _generate_alert_description(self, state: CognitiveState, pattern: str) -> str:
        """Generate human-readable alert description."""
        descriptions = {
            'learning_planning': f"User {state.user_id} shows learning and planning patterns with elevated intent ({state.intent:.2f})",
            'persistence_after_failure': f"User {state.user_id} demonstrates persistence after failures with increasing intent ({state.intent:.2f})",
            'malicious_confidence': f"User {state.user_id} exhibits malicious confidence with high risk tolerance ({state.risk_tolerance:.2f})",
            'imminent_risk': f"User {state.user_id} shows imminent risk indicators with high goal proximity ({state.goal_proximity:.2f})",
            'normal': f"User {state.user_id} has elevated risk score ({state.intent * state.goal_proximity * state.capability:.2f})"
        }
        
        return descriptions.get(pattern, descriptions['normal'])
    
    def _trigger_alert_callbacks(self, alert: Alert):
        """Trigger all registered alert callbacks."""
        for callback in self._alert_callbacks:
            try:
                callback(alert)
            except Exception as e:
                print(f"Error in alert callback: {e}")
    
    def _start_processing(self):
        """Start the background processing thread."""
        self._processing_thread = threading.Thread(target=self._process_events, daemon=True)
        self._processing_thread.start()
    
    def _process_events(self):
        """Background thread for processing events from queue."""
        while not self._stop_processing:
            try:
                # Get event from queue with timeout
                event_data = self._event_queue.get(timeout=1.0)
                
                # Process the event
                self.process_event(event_data)
                
                # Mark task as done
                self._event_queue.task_done()
                
            except queue.Empty:
                # Timeout is normal, continue
                continue
            except Exception as e:
                print(f"Error in background processing: {e}")
                continue
    
    def process_batch(self, events: List[Dict[str, Any]]) -> List[Alert]:
        """
        Process a batch of events.
        
        Args:
            events: List of event dictionaries
            
        Returns:
            List of alerts generated
        """
        alerts = []
        
        for event_data in events:
            alert = self.process_event(event_data)
            if alert:
                alerts.append(alert)
        
        return alerts
    
    def get_user_summary(self, user_id: str) -> Optional[Dict[str, Any]]:
        """
        Get comprehensive summary for a user.
        
        Args:
            user_id: User identifier
            
        Returns:
            User summary or None if user doesn't exist
        """
        state = self.state_store.get_state(user_id)
        trajectory = self.state_store.get_user_trajectory(user_id)
        behavioral_context = self.behavioral_adapter.get_behavioral_context(user_id)
        
        return {
            'user_id': user_id,
            'cognitive_state': state.to_dict(),
            'trajectory': trajectory,
            'behavioral_context': behavioral_context,
            'risk_score': state.intent * state.goal_proximity * state.capability,
            'is_high_risk': (state.intent * state.goal_proximity * state.capability) > self.config.alert_combined_threshold
        }
